package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"net/url"
	"time"

	"github.com/dave-andrew/gqlgen-todos/graph/model"
	"github.com/dave-andrew/gqlgen-todos/hash"
	"github.com/dave-andrew/gqlgen-todos/middleware"
	"github.com/dave-andrew/gqlgen-todos/verification"
	"github.com/golang-jwt/jwt"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, newUser model.NewUser) (string, error) {
	hashPassword, _ := hash.HashPass(newUser.Password)

	users := &model.User{
		ID:             uuid.NewString(),
		Name:           newUser.Name,
		Surname:        newUser.Surname,
		Email:          newUser.Email,
		Dob:            newUser.Dob,
		Gender:         newUser.Gender,
		Password:       hashPassword,
		Approved:       false,
		HomePicture:    "",
		ProfilePicture: "",
	}

	if err := r.Db.Create(users).Error; err != nil {
		return "", err
	}

	token, _ := middleware.GenerateJWTToken(users.ID)

	message, err := verification.EmailVerification(newUser.Email, token)

	return message, err
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, newUser model.NewUser) (*model.User, error) {
	var users model.User
	if err := r.Db.Where("Name = ?", newUser.Name).First(&users).Error; err != nil {
		return nil, err
	}

	hash, _ := hash.HashPass(newUser.Password)

	if newUser.Password != "" {
		users.Password = hash
	}

	if err := r.Db.Where("Name = ?", newUser.Name).Updates(&users).Error; err != nil {
		return nil, err
	}

	return &users, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, token string, oldpass string, pass string) (string, error) {
	//panic(fmt.Errorf("not implemented: ChangePassword - changePassword"))
	decode, err := base64.StdEncoding.DecodeString(token)

	if err != nil {
		fmt.Println("Error decoding base64:", err)
		return "", err
	}

	oriToken, err := url.PathUnescape(string(decode))

	if err != nil {
		fmt.Println("Error unescaping URL:", err)
		return "", err
	}

	jwtToken, err := middleware.ValidateJWTToken(oriToken)
	if err != nil {
		return "", err
	}

	claims, ok := jwtToken.Claims.(jwt.MapClaims)
	if !ok {
		return "", nil
	}

	userid, ok := claims["user_id"].(string)
	if !ok {
		return "", fmt.Errorf("userid not found")
	}

	// println(userid)

	var user *model.User
	if err := r.Db.Where("ID = ?", userid).First(&user).Error; err != nil {
		return "", err
	}

	if !comparePasswords(oldpass, user.Password) {
		return "", fmt.Errorf("Old password is incorrect")
	}

	if comparePasswords(pass, user.Password) {
		return "", fmt.Errorf("New password must be different from the old password")
	}

	user.Password, _ = hash.HashPass(pass)

	if err := r.Db.Save(&user).Error; err != nil {
		return "", err
	}

	return "Password Changed!", nil
}

// AddProfilePicture is the resolver for the addProfilePicture field.
func (r *mutationResolver) AddProfilePicture(ctx context.Context, url string) (string, error) {
	//panic(fmt.Errorf("not implemented: AddProfilePicture - addProfilePicture"))
	token := ctx.Value("TokenValue")

	jwtToken, _ := middleware.ValidateJWTToken(token.(string))

	claims, _ := jwtToken.Claims.(jwt.MapClaims)

	userid, _ := claims["user_id"].(string)

	var user *model.User
	if err := r.Db.Where("ID = ?", userid).First(&user).Error; err != nil {
		return "", err
	}

	user.ProfilePicture = url
	if err := r.Db.Save(&user).Error; err != nil {
		return "", err
	}

	return "Changes Saved!", nil
}

// AddHomePicture is the resolver for the addHomePicture field.
func (r *mutationResolver) AddHomePicture(ctx context.Context, url string) (string, error) {
	//panic(fmt.Errorf("not implemented: AddHomePicture - addHomePicture"))
	token := ctx.Value("TokenValue")

	jwtToken, _ := middleware.ValidateJWTToken(token.(string))

	claims, _ := jwtToken.Claims.(jwt.MapClaims)

	userid, _ := claims["user_id"].(string)

	var user *model.User
	if err := r.Db.Where("ID = ?", userid).First(&user).Error; err != nil {
		return "", err
	}

	user.HomePicture = url
	if err := r.Db.Save(&user).Error; err != nil {
		return "", err
	}

	return "Changes Saved!", nil
}

// UpdateUserProfile is the resolver for the updateUserProfile field.
func (r *mutationResolver) UpdateUserProfile(ctx context.Context, name string, surname string, dob time.Time) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: UpdateUserProfile - updateUserProfile"))

	token := ctx.Value("TokenValue")

	jwtToken, _ := middleware.ValidateJWTToken(token.(string))

	claims, _ := jwtToken.Claims.(jwt.MapClaims)

	userid, _ := claims["user_id"].(string)

	var user *model.User

	if err := r.Db.Where("ID = ?", userid).First(&user).Error; err != nil {
		return nil, err
	}

	user.Name = name
	user.Surname = surname
	user.Dob = dob

	if err := r.Db.Save(&user).Error; err != nil {
		return nil, err
	}

	return user, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context) (*model.User, error) {
	//panic(fmt.Errorf("not implemented: GetUser - getUser"))
	token := ctx.Value("TokenValue")

	jwtToken, _ := middleware.ValidateJWTToken(token.(string))

	claims, _ := jwtToken.Claims.(jwt.MapClaims)

	userid, _ := claims["user_id"].(string)

	var user *model.User

	if err := r.Db.Where("id = ?", userid).First(&user).Error; err != nil {
		return nil, err
	}

	return user, nil
}

// GetAllUser is the resolver for the getAllUser field.
func (r *queryResolver) GetAllUser(ctx context.Context) ([]*model.User, error) {
	var allUser []*model.User

	if err := r.Db.Where("approved = ?", true).Find(&allUser).Error; err != nil {
		return nil, err
	}

	return allUser, nil
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, input model.InputLogin) (string, error) {
	var user *model.User
	if err := r.Db.Where("email = ?", input.Email).First(&user).Error; err != nil {
		return "", err
	}

	if !hash.CheckPass(input.Password, user.Password) {
		return "", errors.New("Wrong Password!")
	}

	if !user.Approved {
		return "", errors.New("Account not verified. Please verify your account first.")
	}

	if user == nil {
		return "", errors.New("Credentials Not Found!")
	}

	token, err := middleware.GenerateJWTToken(user.ID)
	if err != nil {
		return "", fmt.Errorf("failed to generate JWT token: %w", err)
	}

	return token, nil
}

// ValidateEmail is the resolver for the ValidateEmail field.
func (r *queryResolver) ValidateEmail(ctx context.Context, token string) (bool, error) {
	decode, err := base64.StdEncoding.DecodeString(token)

	if err != nil {
		return false, err
	}

	oriToken, err := url.PathUnescape(string(decode))

	if err != nil {
		return false, err
	}

	jwtToken, err := middleware.ValidateJWTToken(oriToken)
	if err != nil {
		return false, err
	}

	claims, ok := jwtToken.Claims.(jwt.MapClaims)
	if !ok {
		return false, nil
	}

	userid, ok := claims["user_id"].(string)
	if !ok {
		return false, fmt.Errorf("userid not found")
	}

	var user *model.User
	if err := r.Db.Where("ID = ?", userid).First(&user).Error; err != nil {
		return false, err
	}

	user.Approved = true
	if err := r.Db.Save(&user).Error; err != nil {
		return false, err
	}

	return true, nil
}

// ChangePasswordEmail is the resolver for the changePasswordEmail field.
func (r *queryResolver) ChangePasswordEmail(ctx context.Context, email string) (string, error) {
	//panic(fmt.Errorf("not implemented: ChangePasswordEmail - changePasswordEmail"))

	var user *model.User
	if err := r.Db.Where("Email = ?", email).First(&user).Error; err != nil {
		return "", err
	}

	return verification.ChangePassword(email, user.ID)
}

// ValidateToken is the resolver for the validateToken field.
func (r *queryResolver) ValidateToken(ctx context.Context, token string) (bool, error) {
	//panic(fmt.Errorf("not implemented: ValidateToken - validateToken"))
	decode, _ := base64.StdEncoding.DecodeString(token)

	oriToken, _ := url.PathUnescape(string(decode))

	jwtToken, _ := middleware.ValidateJWTToken(oriToken)

	claims, _ := jwtToken.Claims.(jwt.MapClaims)

	userid, _ := claims["user_id"].(string)

	var user *model.User
	if err := r.Db.Where("ID = ?", userid).First(&user).Error; err != nil {
		return false, nil
	}

	if user == nil {
		return false, errors.New("Token Not Valid")
	}

	return true, nil
}

// GetUserByName is the resolver for the getUserByName field.
func (r *queryResolver) GetUserByName(ctx context.Context, name string) (*model.User, error) {
	//panic(fmt.Errorf("not implemented: GetUserByName - getUserByName"))
	var user *model.User

	if err := r.Db.Where("name = ?", name).First(&user).Error; err != nil {
		return nil, err
	}

	return user, nil
}

// SearchUser is the resolver for the searchUser field.
func (r *queryResolver) SearchUser(ctx context.Context, search string) ([]*model.User, error) {
	// panic(fmt.Errorf("not implemented: SearchUser - searchUser"))

	var user []*model.User

	if err := r.Db.Where("name LIKE ? AND approved = ?", "%"+search+"%", true).Find(&user).Error; err != nil {
		return nil, err
	}

	return user, nil
}

// ValidateeToken is the resolver for the validateeToken field.
func (r *queryResolver) ValidateeToken(ctx context.Context, token string) (bool, error) {
	// panic(fmt.Errorf("not implemented: ValidateeToken - validateeToken"))

	oriToken, _ := url.PathUnescape(token)

	jwtToken, _ := middleware.ValidateJWTToken(oriToken)

	claims, _ := jwtToken.Claims.(jwt.MapClaims)

	userid, _ := claims["user_id"].(string)

	var user *model.User
	if err := r.Db.Where("ID = ?", userid).First(&user).Error; err != nil {
		return false, nil
	}

	if user == nil {
		return false, errors.New("Token Not Valid")
	}

	return true, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func comparePasswords(plainPassword, hashedPassword string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(plainPassword))
	return err == nil
}
